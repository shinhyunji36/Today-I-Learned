> **일시**: 2023년 01월 10일 화 `18:30` ~ `20:40`

## [책] 클린코드 이제는 파이썬이다
### 02장. 환경 설정과 명령행 사용 방법
### 파일 시스템
- 파일 시스템: 운영체제가 저장하고 검색할 데이터를 구성하는 기반
- 파일: filename과 path(컴퓨터에서 파일의 위치) 두 가지 주요 속성을 지닌다.
- 경로의 `C:\` 부분은 root folder로, 모든 하위 폴더가 들어 있는 곳
  - 윈도우의 루트 폴더: `C:\`, C: 드라이브
  - 맥, 리눅스의 루트 폴더: 대화형 쉘에 입력할 경우, `C:\` 가 아니라, `/` 를 입력해야 한다.
- 파일명 대소문자 구분
  - 윈도우와 맥은 대소문자를 구분하지 않는다
  - 리눅스는 대소문자 구분한다.

#### 파이썬의 경로
- 윈도우에서는 폴더와 파일명을 `\`(백슬래시)로 분리
- 맥과 리눅스에서는 `/`(슬래시)로 분리
- 여러 플랫폼에서 파이썬 스크립트가 호환 가능하게 하려면, **`pathlib` 모듈과 `/`연산자를 사용할 수 있다**.
  - Path()는 맥과 리눅스에서는 `PosixPath`를 윈도우에서는 `WindowsPath`객체를 반환한다.
  ```python
  >>> from pathlib import Path
  >>> Path('spam') / 'bacon' / 'eggs'
  PosixPath('spam/bacon/eggs')
  ```
  - 파일명을 파라미터로 받는 파이썬 표준 라이브러리의 모든 함수에 Path 객체를 전달할 수 있다. 
    ```python
    # 이 둘의 실행 결과는 같다.
    open(Path('C:\\') / 'Users' / 'Al' / 'Desktop' / 'spam.py')
    open(r'C:\Users\Al\spam.py')
    ```
  
#### 홈 디렉터리
- 모든 사용자는 각자 컴퓨터 마다 자신의 파일을 저장할 수 있는 홈 디렉텨리라는 폴더를 가지고 있다
- `Path.home()`을 호출하면 홈 폴더의 Path 객체를 얻을 수 있다.
```python 
>>> Path.home()
PosixPath('/Users/hyunjishin')
```

- 홈 디렉터리는 운영체제에 따라 정해진 위치가 있다.
  - 윈도우: `C:\Users`
  - 맥: `/Users`
  - 리눅스: `/home`

#### 현재 작업 디렉터리
- CWD: Current Working Directory(현재 작업 디렉터리)
- `Path.cwd()`
```python
>>> Path.cwd()
PosixPath('/Users/hyunjishin')
```

- `os.chdir()`로 현재 작업 디렉토리를 변경할 수 있다.
  - 이 때, 존재하지 않는 디렉터리로 변경하려면 파이썬은 FileNotFoundError를 발생시킨다.

- `os.getcwd()`는 현재 작업 디렉터리를 문자열로 얻기 위해 사용되던 방식

#### 절대 경로 vs. 상대 경로
- 파일 경로를 지정하는 방식은 두가지이다.
  - 항상 루트 폴더에서 시작되는 절대 경로
  - 프로그램의 현재 작업 디렉터리에 따라 달라지는 상대 경로
- `.`과 `..`
  - `.`: 현재 위치한 디렉터리
  - `..`: 상위 디렉터리

### 프로그램과 프로세스
- 프로그램: 모든 소프트웨어 응용 프로그램
- 프로세스: 프로그램의 실행 인스턴스
  - 프로세스는 서로 분리된 상태로 유지된다.
  - 따라서 하나의 프로그램이 여러 인스턴스를 동시에 실행하더라도, 각 프로세스는 서로 별도의 변수값을 가지고 있을 수 있다.
- 실행중인 프로세스 목록 보기 > 작업관리자는 동작중인 프로세스 강제 종료 가능
  - 우분투 리눅스: CTRL-ALR-DEL 작업관리자 확인
  - 맥: 응용프로그램 > 유틸리티 > 활성상태보기
  - 윈도우: CTRL-SHIFT-ESC 작업관리자 확인

### 명령행
- 명령행: command line
- 명령행 인터페이스(CLI)
- 그래픽 사용자 인터페이스(GUI)

- 운영체제 별 쉘 프로그램 위치
  - 윈도우: `C:\Windows\System32\cmd.exe`
  - 맥: `/bin/bash` 
    - c.f. 맥은 카탈리나 이후 버전에서 Zsh(Zshell)을 사용한다.
  - 리눅스: `/bin/bash`

#### 명령행 인수
- 명령행 인수는 명령어 뒤에 입력하는 텍스트 조각들
  - 폴더나 파일 명이 일반적인 명령행 인수.
  - 폴더나 파일명에 공백이 들어 있다면, 명령행이 혼동하지 않도록 이름을 큰따옴표로 묶어야 한다. e.g. `cd "Vacation Photos"`
  - 또다른 명령형 인수 중 하나는 맥과 리눅스에서 사용하는 `-help`, 윈도우의 `/?` 옵션
- 명령행 옵션은 단일 문자 혹은 짧은 단어로 이뤄진 명령행 인수 e.g. `tail -f output.log` 에서 `-f`

#### 필수 명령어 모음
- 와일드 카드 문자로 폴더와 파일명 일치시키기 (*와 ?를 사용하는 글로브 패턴)
  - `*`: 개수와 무관하게 문자들을 받아들음
    - e.g. 파이썬 파일만 보고 싶을 때 `ls *.py`
  - `?`: 문자 하나만을 받아들인다.
    - e.g. 년도별 레코드 텍스트 파일을 찾고 싶을 때, `recores201?.txt`

#### dir과 ls를 활용한 폴더 내용 열거
- 윈도우에서는 `dir`명령어 사용
- 맥과 리눅스: `ls`
  - `-l` 옵션: 파일 크기나 권한, 마지막 수정 시점을 알려주는 타임스탬프 등 여러 정보 포함해서 긴 목록 형식으로 표시
    - 기본적으로 `ls`는 파일과 폴더의 이름만 표시한다.
  - `-a` 옵션: 숨겨진 파일을 포함한 모든 파일을 ls 명령어가 표시
    - 관례에 따라서 맥과 리눅스는 마침표로 시작하는 파일을 설정 파일로 취급해 ls같은 일반 명령어로부터 숨긴다.
  -  `-al`: 위에 두 옵션 합쳐서 적용

- dir /s와 find를 활용한 하위 폴더 내용 열거
 - 맥과 리눅스에서 `find . -name "*.py"`
  - 마침표는 현재 작업 디렉터리에서 검색을 시작하라는 뜻
  - `-name`옵션은 이름으로 폴더나 파일명을 찾으라고 find에게 알려준다.
  -  `"*.py"`는 find가 해당 패턴과 일치하는 폴더와 파일을 찾으라고 알려준다. (반드시 -name 뒤의 인수는 큰따옴표로 묶어줘야 한다.)

- `cp [원본 파일 혹은 폴더] [대상 폴더]`: 파일과 폴더 복사
- `mv [원본 파일 또는 폴더] [대상 폴더]`: 파일과 폴더 이동 // 이름 변경도 가능 (맥과 리눅스)
- `rm [파일]`: 파일 삭제
- `rm -r [폴더]`: 폴더와 폴더 내 모든 내용 삭제
- `mkdir [새폴더]`: 폴더 생성
- `rmdir [원본 폴더]`: 비어 있는 폴더 삭제
- `rmdir -rf [원본 폴더]`: 비어 있지 않은 폴더(와 그 안에 포함된 모든 폴더와 파일) 삭제
- `which [프로그램]`: 프로그램의 정확한 위치 확인. 해당 프로그램이 PATH 환경 변수에 설정된 폴더 안에 있는지 확인한다.
  - e.g. `which python`: 실행 가능한 파이썬 프로그램 가운데 어떤 버전이 동작할지 알려준다.
- `clear`: 터미널 내용 삭제

### 환경 변수와 PATH
- 프로그램의 모든 실행 프로세스에는 문자열을 저장할 수 있는 환경변수라는 변수 집합이 있다. 
- 운영체제가 프로그램(명령행 등)을 실행할 때, 새로 생성된 프로세스는 운영체제의 환경 변수와 그 값에 대한 독자적인 사본(copy)을 받는다. 
  - 따라서 운영체제의 환경 변수 집합과 무관하게 독립적으로 프로세스마다 환경 변수를 변경할 수 있다. 
  - 그러나 이러한 변경사항은 해당 프로세스에만 적용되며, 운영체제나 다른 프로세스와는 무관하다. (일회용)

#### 환경 변수 보기
- 맥과 리눅스에서 `env`를 실행하면 터미널 창에 떠있는 쉘의 환경 변수 목록을 볼 수 있다.
- 등호(=)의 왼쪽에 있는 텍스트는 환경 변수명
- 등호(=)의 오른쪽에 있는 텍트는 문자열 값
- 프로세스마다 환경 변수 집합은 고유하며,명령행에서 수행하는 프로세스에 따라 환경 변수의 값도 달라질 수 있다.

  ```python
  >> env
  ...
  
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  MANPATH=/opt/homebrew/share/man::
  INFOPATH=/opt/homebrew/share/info:
  ZSH=/Users/hyunjishin/.oh-my-zsh
  PAGER=less
  LESS=-R
  LSCOLORS=Gxfxcxd
  ```
  
- 또한, `echo`로 특정한 환경 변수의 값을 볼 수 있다.
- 현재 사용자의 홈 폴더를 나타내는 HOME 환경 변수의 값을 보려면, 리눅스에서 `echo $HOME`을 실행한다.
  ```python
   >> echo $HOME
   /Users/hyunjishin
  ```

- 어떤 프로세스가 다른 프로세스를 생성하는 경우, 
  - 자식 프로세스는 부모 프로세스로 부터 환경 변수에 대한 독자적인 사본을 받는다.
  - 이 때문에 자식 프로세스는 부모 프로세스의 환경 변수에 영향을 미치지 않고, 자신만의 환경 변수값을 변경할 수 있으며, 그 반대도 마찬가지.
  - 운영체제의 환경 변수 집합을 프로세스가 환경 변수를 복사하는 `마스터 사본`이라고 생각해도 좋다.

#### PATH 환경 변수를 이용한 작업
- 맥과 리눅스에서 `python3`같은 명령어를 입력하면, 터미널은 현재 있는 폴더에서 해당 이름의 프로그램을 확인한다.
- 거기서 찾지 못하면, PATH 환경 변수에 나열된 폴더들을 확인하기 시작한다.
- 쓰임새
  - e.g. 윈도우 컴퓨터 내에서 python.exe 프로그램 파일은 `C:\Users\Al\AppData\Local\Programs\Python38`폴더에 위치한다.
    - python.exe 명령어를 실행하려면, `C:\Users\Al\AppData\Local\Programs\Python38\python.exe`를 입력하거나, 해당 폴더로 먼저 전환한 후 python.exe를 입력해야한다.
    - 경로 명이 길어지면 입력할 글자 수도 늘어나므로 대신 PATH 환경 변수에 이 폴더를 추가한다. 
      - 그 후에 python.exe를 입력하면, 명령행이 PATH에 나열된 폴더에서 해당 이름의 프로그램을 검색해서 전체 파일 경로를 입력해야하는 수고를 덜어준다.
- 환경변수는 단일 문자열 값만 포함할 수 있기 때문에, PATH 환경 변수에 여러 폴더 이름을 추가하려면 특별한 형식을 사용해야 한다!
  - 윈도우에서는 세미콜론(;)으로 폴더 이름을 구별한다.
  - 맥과 리눅스는 콜론(:)으로 폴더 이름을 구분한다.
    - e.g.
      ```python
      >> echo PATH
      /home/al/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/loacal/games:/snap/bin
      ```
  - 여기서 폴더 명의 순서가 중요하다!
  - someProgram.exe라는 이름의 파일 2개가 `C:\WINDOWS\system32`와 `C:\WINDOWS`에 모두 존재할 경우, 
    - 우리가 someProgram.exe를 명령 프롬프트에 입력하면, PATH 환경 번수에서 먼저 등장한 `C:\WINDOWS\system32` 폴더 안의 프로그램이 실행된다.
- 입력한 프로그램이나 명령어가 현재 작업 디렉터리나 PATH에 열거된 디렉터리 등에 존재하지 않는 경우 명령행은 에러를 표시한다.
  - 리눅스의 경우, command not found 에러 메세지가 나온다.

#### 명령행의 PATH 환경 변수 바꾸기
- 현재 터미널 창의 PATH 환경 변수에 폴더를 추가하게끔 변경할 수 있다.
- PATH에 폴더를 추가하는 과정 (맥/리눅스)
  ```python
  >> PATH=/newFolder:$PATH #1
  >> echo $PATH #2
  /newFolder:/home/al/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
  ```
  - #1 `$PATH` 부분이 PATH 환경 변수의 현재 값을 확장한다.
    - 따라서 기존 PATH 값의 앞 부분에 새 폴더와 콜론을 추가한다.
  - #2를 통해 #1에서 `/newFolder`까지 업데이트된 PATH 환경변수를 확인할 수 있다. 
  - 그러나! 이 방법으로 PATH에 추가된 폴더는 **현재 터미널 창에만 적용**된다.
  - 새 터미널 창을 열면 이 변경 내용은 반영되지 않는다. 영구적으로 추가하려면, 운영체제의 환경 변수 집합을 변경해야 한다.

#### 폴더를 영구적으로 PATH에 추가': 맥과 리눅스
- 모든 터미널창에 적용되도록 PATH 환경 변수에 폴더를 추가하려면, 홈 폴더의 `.bashrc`파일을 수정해서 다음과 같은 행을 추가해야한다.
  ```python
  # 홈 폴더의 .bashrc 파일 내 아래 행 추가하기
  export PATH=/newFolder:$PATH
  ```
- 이 한줄로 모든 터미널 창에 대한 PATH 수정 가능!
- cf. 맥 OS 카탈리나 이후 버전에서는 기본 쉘 프로그램이 Bash에서 Zsh(z shell)로 변경되어, 홈 폴더에서 `.zshrc`를 수정해야 한다.

### 명령행을 쓰지 않고 파이썬 프로그램을 실행하는 방법
#### 맥OS 환경
- 맥OS에서는 `.command` 파일 확장자를 가진 텍스트 파일로 파이썬 스크립트를 실행할 셸 스크립트를 만들 수 있다.
  ```
  #!/usr/bin/env bash
  pyton3 /path/to/yourScript.py
  ```
  - 이 파일을 홈 폴더에 저장한 다음, 
  - 터미널 창에서 `chmod u+x yourScript.command` 명령어로 이 쉘 스크립트를 실행 가능하게 만든다. 
  - 이후 스포트라이트 아이콘을 클릭하고 쉘 스크립트의 이름을 입력해서 실행 가능. 

#### 우분투 리눅스 환경
- `.py` 파일이 홈 폴더에 있는지 확인
- 다음 행을 `.py` 파일의 맨 위에 추가
  `#!/usr/bin/env python3`
  - 셔병 행(shebang line)이라고 불리는 이 행
  - 우분투에서 이 파일을 실행할 때 파이썬3을 사용하고 싶다고 알려주는 역할
- 이후 터미널에서 chmod 명령어를 실행해 이 파일에 실행 권한을 추가한다
  `chmod u+x yourScript.py`
- 그 후, 새로 연 터미널 창에서 `./yourScript.py` 만 입력하면 된다.




  










  
